//
//  main.cpp
//  7.18_intro.to.random.number.generation
//
//  Created by εκλεγμένοι εν Χριστώ on 1/28/23.
//

/*
 Algorithm : finite sequence of instructions that can be followed to solve some problem or
 produce some useful result.
 
 Algorithms : reusable
 
 Algorithms : automate the tasks
 
 C++ algorithms : typically implemented as reusable functions
 
 Stateful algorithm : if it retains some information across calls
 
 Stateless algorithm : does not store any information, must be given all the information it
 needs to work with when it is called.
 
 State : refers to the current values held in stateful variables
 
 Deterministic algorithm : for a given input(start value), it will always produce the same
 output sequence.
 
 PRNGs : algorithm that generates a sequence of numbers whose properties simulate a sequence
 of random numbers.
 
 Most PRNGs : work similarly to LCG16, they typically use more state variables and more
 complex mathematical operations to generate best quality results
 
 PRNG : random numbers generated by PRNG is not random at all
 LCG16 : also deterministic, once the state has been initialized, LCG16 will generate the
 same output sequence.
 
 Random seed : when PRNG is instantiated, initial value provided to initialize the state of
 PRNG. When PRNG has been initialized with a seed, we say it has been seeded.
 
 Quality result producing PRNGs : use at least 16 bytes of state
 
 Under-seeded PRNG : the size of the seed value can be smaller than the size  of the state
 of the PRNG.
 
 Ideally-
 every bit in the state : initialized from a seed of equal size
 every bit in the seed : has been independently determined somehow
 
 if a PRNG is under-seeded:
 some number of bits in the state : need to be initialized from the same bits in the seed
 
 if a PRNG is significantly under-seeded:
 the quality of the random results the PRNG produces : can be impacted
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 What makes a good PRNG?
 properties of a good prng:
 -it should generate each number with approximately the same probability
 -method by which next number in sequence is generated shouldn't be predictable
 -it should have a good dimensional distribution of numbers
 -it should have a high period for all seeds
 -it should be efficient
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 -IT SHOULD GENERATE EACH NUMBER WITH APPROXIMATELY THE SAME PROBABILITY:
 
 Distribution uniformity : it should generate each number with approximately the same
 probability
 
 Biased PRNG : if some numbers generated more often than others
 
 checking distribution uniformity : we can use a histogram
 
 histogram : graph that tracks how many times each number has been generated
 
 example: considering a PRNG that generates numbers between 1 and 6, if 36 numbers are
 generated, then distribution uniformity should generate a histogram like this:

 1|******
 2|******
 3|******                 '*' used to denote each time a given number was generated
 4|******
 5|******
 6|******
 
 a biased prng will generate the histogram like this:
 
 1|***
 2|******
 3|******
 4|******
 5|******
 6|*********
 
 or maybe this:
 
 1|****
 2|********
 3|******
 4|********
 5|******
 6|****
 
 simple example for distribution uniformity-
 let say you're trying to write a random number generator for a game:
 when a monster is killed, the code generates a random number between 1 and 6, if the result
 is 6 the monster will drop a rare item instead of a common one. you would expect a 1 in 6
 chance of this happening, but if underlying PRNG is not uniform, and generates a lot more
 6s than it should, then players will end up getting more rare items than the intended, that
 will trivialize the difficulty of game or mess up the in-game economy
 --uniform result producing prng algorithms are difficult to find.
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 -METHOD BY WHICH NEXT NUMBER IN SEQUENCE IS GENERATED SHOULDN'T BE PREDICTABLE:
 
 considering the following PRNG algorithm-
 
 return ++num;
 
 this prng is perfectly uniform, but also completely predictable, not very useful as a
 sequence of random numbers
 
 every sequence of numbers : that seem random to the eye(like LCG16), may be trivially
 predictable by someone, by examining just a few numbers generated from LCG16, it is
 possible to determine which constants are used to modify the state, one that is known, it
 becomes trivial to calculate all of the future numbers that will be generated from this
 PRNG
 
 example-
 imagine a website where users can bet $100, then website generates a random number between
 0 and 32767, if number is greater than 20000, then user wins and he get double the amount,
 otherwise he lose. since the customer wins only 12767/32767 which is 39% of the time, then
 website should make tons of money, if user is able to determine which numbers will be
 generated next, then he can strategically place bets so he always win, this way website
 goes bankrupt
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 -IT SHOULD HAVE A GOOD DIMENSIONAL DISTRIBUTION OF NUMBERS:
 
 prng should return numbers across the entire range of possible results at random
 
 example-
 it should generate low numbers, middle numbers, high numbers, even, odd seemingly at random
 
 a prng that returned all low numbers:
 then all high numbers maybe uniform and non-predictable, it's still going to lead to biased
 results, especially if the number of random numbers which are to be used is small
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 -IT SHOULD HAVE A HIGH PERIOD FOR ALL SEEDS:
 
 PRNGs : are periodic, at some point the sequence of numbers generated will begin to repeat
 itself.
 
 Period : length of the sequence before a prng begins to repeat itself
 
 example-
 112    9     130   97    64    31    152    119   86     53
 20     141   108   75    42    9     130    97    64     31
 152    119   86    53    20    141   108    75    42     9
 130    97    64    31    152   119   86     53    20     141
 108    75    42    9     130   97    64     31    152    119
 86     53    20    141   108   75    42     9     130    97
 64     31    152   119   86    53    20     141   108    75
 42     9     130   97    64    31    152    119   86     53
 20     141   108   75    42    9     130    97    64     31
 152    119   86    53    20    141   108    75    42     9
 
 observation from above example : this prng is stuck generating the following repeatedly
 9-130-97-64-31-152-119-86-53-20-141-108-75-42-(repeat).
 
 PRNG : should have a long period for all seeds
 
 many PRNGs : have long periods for some seeds and not others
 
 if user picks a seed that results in state with a short period, the PRNG won't do good job
 if many random numbers are needed
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 -THE PRNG SHOULD BE EFFICIENT:
 
 most PRNGs : have a state size of less than 4096 bytes, total memory usage typically isn't
 a concern
 
 the larger the internal state : the more likely PRNG is to be under-seeded, slower the
 initial seeding will be(since there is more state to initialize).
 
 to generate the next number in the sequence : PRNG has to mix up its internal state by
 applying various mathematical operations
 
 it can have a huge impact if there is a need of lots of randomness
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 
 randomization capabilities in cpp are accessible via the : <random> header of STD library
 
 6 available families of PRNG for use(as of cpp2020):
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 type name      family          period      state size      performance quality should i use
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 minstd_rand    LCG             2^31        4 Bytes         bad         awful   no
 minstd_rand0   LCG             2^31        4 Bytes         bad         awful   no
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 mt19937        Mersenne        2^19937     2500 bytes      decent      decent  probably
                twister
 mt19937_64     ''              2^19937     2500 bytes      decent      decent  probably
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 ranlux24       subtract and    10^171      96 bytes        awful       good    no
                carry
 ranlux48       ''              10^171      96 bytes        awful       good    no
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 knuth_b        shuffled LCG    2^31        1028 bytes      awful       bad     no
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 default_random any of above    varies      varies          ?           ?       No^2
 _engine
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 rand()         LCG             2^31        4 bytes         bad         awful   No^no
 –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 
 
 
 for most applications : Mersenne twister is fine, both in terms of performance and quality
 by modern PRNG standards : Mersenne twister is bit outdated
 Mersenne twister : results can be predicted after seeing 624 generated numbers, it becomes
 non suitable for applications that require non-predictability
 
 3rd party libraries for non-predictability and high quality random results:
 xoshiro family and Wyrand : for non cryptographic PRNGs
 chacha family : for cryptographic PRNGs(non-predictable)
 */

#include <iostream>

/// this algorithm is stateful, because of static variable used inside
/// simple algorithm to generate a sequence of numbers, each successive number is incremented by 1
int plus_one()
{
    /// initialize only once
    static int s_state{3};
    
    /// modifying the current state to produce new state
    ++s_state;
    
    /// using the new state to generate the next number in the sequence
    return s_state;
}

unsigned int LCG16()
{
    static unsigned int s_state{5323};
    
    /// first, modify the state
    /// it is hard to casually predict what the next number is going to be from the previous one
    /// due to the use of large constants and overflow
    s_state = 8253729 * s_state + 2396403;
    
    /// using the new state to generate the next number in the sequence
    return s_state % 32768;
}

int main()
{
    std::cout << plus_one() << '\n';
    std::cout << plus_one() << '\n';
    std::cout << plus_one() << '\n';
    std::cout << plus_one() << '\n';
    
    for (int count{1}; count <= 100; ++count)
    {
        std::cout << LCG16() << '\t';
        
        /// starting a new row if 10 numbers have printed
        if (count % 10 == 0)
            std::cout << '\n';
    }
    
    return 0;
}
